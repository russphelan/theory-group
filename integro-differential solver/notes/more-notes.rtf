{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fmodern\fcharset0 Courier-Bold;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww14200\viewh16960\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs44 \cf0 area = area + ((r_funcs(2,b)-r_funcs(2,a))/6)*(r_funcs(1,a)/(t-r_funcs(2,a)) + 4*r_funcs(1,mid)/(t-(r_funcs(2,a)+r_funcs(2,b))/2) + r_funcs(1,b)/(t-r_funcs(2,b)); 
\fs48 \

\fs36 \
\
*****\
\
start_index = 1, end_index = 5, actual end is 3. \
eps_steps = 1, step_size =.01, parab_size = 1.\
\
a=1, b=3, mid=2\
\
NEXT ITER\
\
a=3,b=5,mid=4\
\
fine, but we have already drawn a parabola over the end index. \
\
want to stop calculation at end_index-eps_steps*parab_size. \
\
what is meant by current time? Then, we can know why r_funcs is hitting the NaN slots in the derivative arrays. \
\
In first iteration, cur_t_index is t0. \
\

\f1\b 3/4/16\
\

\f0\b0 r_funcs is returning NaNs. I think it\'92s because it depends on the derivatives, and its pulling NaNs out of those matrices. \
\
replaced cur_t_index in calls to scale_1deriv with curr_t_index-1 so that it doesn\'92t hit the NaN slot. \
\
Now, iterations finish, but area is always a NaN. }