{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww14200\viewh8000\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Notes on Implementing Quantum Loop Grav Eqn Solver\
\

\b0 Quantum Behavior setting is currently using Eqn 75.\
\
Classical Behavior is using unmodified Friedman eons\
\
Friedman.m function is not being accessed right now, this got folded into equations.m\
\
\

\b Integrals need to be re-performed after each runge-kutta step. This is because the values for a, a_dd, etc will change after each step, thus changing the value of not just the current integral step, but also past steps. \
\

\b0 \
\
We start initial conditions in domain when classical sol is valid, integral is very small. \
\
First step is regular runge-kutta step. Second step as well. \
\
Then, can calculate first first deriv entry from first two steps. Second first deriv entry from 2nd -> 3rd step. Third from 3rd->4th, etc. 
\b Gets first deriv. \
\

\b0 \
\
Diagram: x\'92s represent a(t) vans. o\'92s represent first deriv vals, z\'92s represent second deriv vals. Left most is start. \
\
x x x x x\
 0 0 0 0\
   z z z\
\
Each element is below the pair of elements that it will be averaging. So, we do not get the first second deriv entry until 
\b after
\b0  the third a(t) entry is calculated. The hope is that each entry is close enough to the previous one that this doesn\'92t cause much inaccuracy. \
\
}